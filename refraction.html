<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Refraction & Snell’s Law — Teaching Edition (A‑Level)</title>
<script src="https://cdn.tailwindcss.com"></script>
<meta name="color-scheme" content="dark light">
<style>
  .section{ border:1px solid rgba(255,255,255,.10); border-radius:1rem; background:rgba(255,255,255,.04); }
  .btn{ border:1px solid rgba(255,255,255,.12); padding:.5rem .8rem; border-radius:.6rem; }
  .btn:hover{ background:rgba(255,255,255,.08) }
  canvas{ image-rendering: crisp-edges; }
</style>
</head>
<body class="min-h-screen bg-slate-950 text-slate-100">
<header class="sticky top-0 z-40 border-b border-white/10 bg-slate-900/60 backdrop-blur">
  <div class="mx-auto max-w-7xl px-3 sm:px-6 py-3 flex items-center gap-3">
    <h1 class="text-lg sm:text-xl font-semibold">Refraction & Snell’s Law — Teaching Edition</h1>
    <div class="ml-auto text-sm text-slate-300">n₁ sinθ₁ = n₂ sinθ₂ • TIR • Brewster</div>
  </div>
</header>

<main class="mx-auto max-w-7xl px-3 sm:px-6 py-5 grid gap-4 xl:grid-cols-[360px_1fr]">
  <aside class="section p-4 space-y-4">
    <div class="grid grid-cols-2 gap-3">
      <div>
        <label class="block text-xs uppercase tracking-wide text-slate-400 mb-1">Medium 1 (n₁)</label>
        <input id="n1" type="range" min="1.00" max="2.00" step="0.01" value="1.00" class="w-full">
        <div class="text-xs text-slate-300">n₁ = <span id="n1Val">1.00</span></div>
      </div>
      <div>
        <label class="block text-xs uppercase tracking-wide text-slate-400 mb-1">Medium 2 (n₂)</label>
        <input id="n2" type="range" min="1.00" max="2.50" step="0.01" value="1.50" class="w-full">
        <div class="text-xs text-slate-300">n₂ = <span id="n2Val">1.50</span></div>
      </div>
    </div>
    <div class="grid grid-cols-2 gap-3">
      <div>
        <label class="block text-xs uppercase tracking-wide text-slate-400 mb-1">Incident angle θ₁ (°)</label>
        <input id="theta" type="range" min="0" max="89" step="1" value="30" class="w-full">
        <div class="text-xs text-slate-300">θ₁ = <span id="thetaVal">30</span>°</div>
      </div>
      <div>
        <label class="block text-xs uppercase tracking-wide text-slate-400 mb-1">Mode</label>
        <select id="mode" class="w-full rounded-md bg-slate-900/60 border border-white/10 px-2 py-2">
          <option value="interface" selected>Flat interface</option>
          <option value="slab">Rectangular slab</option>
          <option value="prism">Prism (60°)</option>
        </select>
      </div>
    </div>
    <div class="grid grid-cols-2 gap-3">
      <div>
        <label class="block text-xs uppercase tracking-wide text-slate-400 mb-1">Wavelength (color)</label>
        <input id="lambda" type="range" min="380" max="700" step="10" value="550" class="w-full">
        <div class="text-xs text-slate-300">λ ≈ <span id="lambdaVal">550</span> nm</div>
      </div>
      <div class="flex items-end">
        <button id="brewster" class="btn w-full">Set to Brewster angle</button>
      </div>
    </div>
    <div class="text-xs text-slate-300 leading-6">
      Snell: n₁ sinθ₁ = n₂ sinθ₂. If n₁ &gt; n₂ and θ₁ &gt; θ_c = arcsin(n₂/n₁), total internal reflection occurs.
      Brewster angle (unpolarised): tanθ_B = n₂ / n₁.
    </div>
  </aside>

  <section class="grid gap-4">
    <div class="section p-3 grid gap-3">
      <canvas id="view" width="1000" height="420" class="w-full rounded-md bg-slate-900 border border-white/10"></canvas>
      <div id="readouts" class="text-sm font-mono px-2"></div>
      <div class="grid sm:grid-cols-2 gap-3">
        <div class="section p-3">
          <div class="text-slate-400 text-xs uppercase mb-1">sinθ plot</div>
          <canvas id="sine" width="500" height="160" class="w-full rounded-md bg-slate-900 border border-white/10"></canvas>
        </div>
        <div class="section p-3">
<pre class="text-slate-200 text-xs leading-6 whitespace-pre-wrap">
θ₂ = arcsin( (n₁/n₂) sinθ₁ )
Critical angle (n₁→n₂, n₁>n₂): θ_c = arcsin(n₂/n₁)
Brewster angle: θ_B = arctan(n₂/n₁)
Deviation (prism, small angles): δ ≈ (n − 1)A
</pre>
        </div>
      </div>
    </div>
  </section>
</main>

<script>
const C = document.getElementById('view'); const ctx=C.getContext('2d');
const S = document.getElementById('sine').getContext('2d');
const out = document.getElementById('readouts');

const st = { n1:1.0, n2:1.5, th:30, mode:'interface', lam:550 };

const ids=s=>document.getElementById(s);
function sync(){
  ids('n1Val').textContent = st.n1.toFixed(2);
  ids('n2Val').textContent = st.n2.toFixed(2);
  ids('thetaVal').textContent = st.th.toFixed(0);
  ids('lambdaVal').textContent = st.lam.toFixed(0);
}
ids('n1').addEventListener('input', e=>{ st.n1=+e.target.value; sync(); draw(); });
ids('n2').addEventListener('input', e=>{ st.n2=+e.target.value; sync(); draw(); });
ids('theta').addEventListener('input', e=>{ st.th=+e.target.value; sync(); draw(); });
ids('mode').addEventListener('change', e=>{ st.mode=e.target.value; draw(); });
ids('lambda').addEventListener('input', e=>{ st.lam=+e.target.value; sync(); draw(); });
ids('brewster').addEventListener('click', ()=>{
  const thB = Math.atan(st.n2/st.n1)*180/Math.PI;
  st.th = thB; ids('theta').value = thB; sync(); draw();
});

function rayColor(){
  const t = (st.lam-380)/(700-380);
  const r = Math.floor(255*Math.min(1, Math.max(0, 2*(t-0.5))));
  const g = Math.floor(255*(1-Math.abs(t-0.5)*2));
  const b = Math.floor(255*Math.min(1, Math.max(0, 1-2*t)));
  return `rgb(${r},${g},${b})`;
}

function draw(){
  const W=C.width, H=C.height;
  ctx.fillStyle="#0f172a"; ctx.fillRect(0,0,W,H);
  ctx.strokeStyle="rgba(148,163,184,.3)"; ctx.setLineDash([6,6]);
  const cx=W/3, cy=H/2;
  // normal
  ctx.beginPath(); ctx.moveTo(cx,0); ctx.lineTo(cx,H); ctx.stroke(); ctx.setLineDash([]);
  // media
  if (st.mode==='interface'){
    ctx.fillStyle="rgba(99,102,241,.15)"; ctx.fillRect(cx,0,W-cx,H);
  } else if (st.mode==='slab'){
    ctx.fillStyle="rgba(99,102,241,.15)"; ctx.fillRect(cx, H/2-90, 320, 180);
  } else {
    // prism 60°
    ctx.fillStyle="rgba(99,102,241,.15)";
    ctx.beginPath();
    ctx.moveTo(cx, H/2+100);
    ctx.lineTo(cx+260, H/2+100);
    ctx.lineTo(cx+130, H/2-125);
    ctx.closePath(); ctx.fill();
  }

  const color = rayColor();
  ctx.strokeStyle=color; ctx.lineWidth=2.5;

  // incident ray
  const th1 = st.th*Math.PI/180;
  const incLen = 240;
  const ix = cx - Math.cos(th1)*incLen, iy = cy - Math.sin(th1)*incLen;
  ctx.beginPath(); ctx.moveTo(ix, iy); ctx.lineTo(cx, cy); ctx.stroke();

  // compute transmitted & reflected depending on geometry
  let info="";
  function drawArrow(ax,ay,bx,by){
    ctx.beginPath(); ctx.moveTo(ax,ay); ctx.lineTo(bx,by); ctx.stroke();
    const ang = Math.atan2(by-ay, bx-ax); const s=8;
    ctx.beginPath(); ctx.moveTo(bx,by);
    ctx.lineTo(bx - s*Math.cos(ang-0.4), by - s*Math.sin(ang-0.4));
    ctx.lineTo(bx - s*Math.cos(ang+0.4), by - s*Math.sin(ang+0.4));
    ctx.closePath(); ctx.fillStyle=color; ctx.fill();
  }

  if (st.mode==='interface'){
    // Snell
    const sin2 = (st.n1/st.n2)*Math.sin(th1);
    if (Math.abs(sin2) > 1){
      // TIR
      const thR = th1; // same as incident to normal
      const rx = cx + Math.cos(thR)*incLen, ry = cy - Math.sin(thR)*incLen;
      drawArrow(cx,cy, rx, ry);
      info = `TIR: θ₁=${(st.th).toFixed(1)}°, θ_c=${(Math.asin(st.n2/st.n1)*180/Math.PI).toFixed(1)}°`;
    } else {
      const th2 = Math.asin(sin2);
      const tx = cx + Math.cos(th2)*incLen, ty = cy - Math.sin(th2)*incLen;
      drawArrow(cx,cy, tx, ty);
      // reflection
      const thR = th1; const rx = cx + Math.cos(thR)*incLen*0.6, ry = cy + Math.sin(thR)*incLen*0.6;
      ctx.globalAlpha=0.5; drawArrow(cx,cy, rx, ry); ctx.globalAlpha=1;
      info = `θ₂=${(th2*180/Math.PI).toFixed(1)}°, Snell OK`;
    }
  } else if (st.mode==='slab'){
    // enter
    const sin2 = (st.n1/st.n2)*Math.sin(th1);
    if (Math.abs(sin2) <= 1){
      const th2 = Math.asin(sin2);
      const len=220;
      drawArrow(cx,cy, cx+Math.cos(th2)*len, cy - Math.sin(th2)*len);
      // exit (parallel to incident, lateral shift)
      const th3 = Math.asin((st.n2/st.n1)*Math.sin(th2));
      const ex = cx+320; const ey = cy - Math.sin(th2)*180;
      drawArrow(ex,ey, ex + Math.cos(th3)*len, ey - Math.sin(th3)*len);
      info = `Slab: θ₂=${(th2*180/Math.PI).toFixed(1)}°, emerging ray ∥ incident (lateral shift)`;
    } else {
      info = "TIR inside the slab";
    }
  } else {
    // prism: treat entrance at left base with normal vertical; refraction, then at sloped side
    const th2 = Math.asin(Math.min(1, Math.max(-1, (st.n1/st.n2)*Math.sin(th1))));
    const enterLen=180;
    const px1 = cx + Math.cos(th2)*enterLen, py1 = cy - Math.sin(th2)*enterLen;
    drawArrow(cx,cy, px1, py1);
    // exit at sloped side: rotate normal by 30°
    const faceAng = -Math.PI/3; // -60° slope
    const localInc = Math.abs(th2 - faceAng);
    const sinOut = (st.n2/st.n1)*Math.sin(localInc);
    if (Math.abs(sinOut)<=1){
      const thOut = Math.asin(sinOut);
      const global = faceAng + thOut;
      drawArrow(px1,py1, px1 + Math.cos(global)*220, py1 + Math.sin(global)*220);
      const dev = (th1 - global)*180/Math.PI;
      info = `Prism: deviation ≈ ${dev.toFixed(1)}°`;
    } else {
      info = "TIR at prism face";
    }
  }

  // readouts
  const thC = (st.n1>st.n2) ? Math.asin(st.n2/st.n1)*180/Math.PI : NaN;
  const thB = Math.atan(st.n2/st.n1)*180/Math.PI;
  out.textContent = `n1=${st.n1.toFixed(2)}  n2=${st.n2.toFixed(2)}  θ1=${st.th.toFixed(1)}°  θc=${isNaN(thC)?"—":thC.toFixed(1)+"°"}  θB≈${thB.toFixed(1)}°  ${info}`;

  // sin plot
  S.fillStyle="#0f172a"; S.fillRect(0,0,500,160);
  S.strokeStyle="rgba(148,163,184,.25)"; S.lineWidth=1;
  for (let y=0;y<160;y+=30){ S.beginPath(); S.moveTo(0,y); S.lineTo(500,y); S.stroke(); }
  const x1 = 40 + (st.th/90)*420;
  const s1 = Math.sin(th1);
  const s2 = Math.min(1, (st.n1/st.n2)*s1);
  function px(th){ return 40 + (th/90)*420; }
  function py(s){ const H=160; return H-30 - s*(H-60); }
  // axes
  S.strokeStyle="rgba(148,163,184,.6)"; S.beginPath(); S.moveTo(40,10); S.lineTo(40,130); S.lineTo(480,130); S.stroke();
  S.fillStyle="rgba(226,232,240,.9)"; S.font="12px ui-sans-serif"; S.fillText("θ (°)", 460, 150); S.save(); S.translate(14, 90); S.rotate(-Math.PI/2); S.fillText("sinθ", 0,0); S.restore();
  // points
  S.fillStyle="#60a5fa"; S.beginPath(); S.arc(px(st.th), py(s1), 4, 0, Math.PI*2); S.fill(); S.fillText("n1 sinθ1", px(st.th)+6, py(s1)-6);
  S.fillStyle="#34d399"; S.beginPath(); S.arc(px(Math.asin(s2)*180/Math.PI), py(s2), 4, 0, Math.PI*2); S.fill(); S.fillText("n2 sinθ2", px(Math.asin(s2)*180/Math.PI)+6, py(s2)-6);
}
sync(); draw();
</script>
</body>
</html>
